const aws = require('aws-sdk');
const ddb = new aws.DynamoDB.DocumentClient();
const sqs = new aws.SQS({ apiVersion: '2012-11-05' });
const bcrypt = require('bcryptjs');

exports.handler = async (event, context) => {
    if (!("invitation" in event.queryStringParameters)) {
        throw "Registration denied";
    }

    const results = await fetchInvitations(event.queryStringParameters.invitation);
    const invitations = results.Items;
    if (invitations.length === 0) {
        return response(404);
    }

    const now = new Date().getTime();
    const freshInvitations = invitations.filter(invitation => invitation.expiresAt > now);
    if (freshInvitations.length === 0) {
        try {
            await refreshInvitation(invitations[0]);
        } catch (error) {
            console.log(error);
            return response(500);
        }

        await purgeInvitation(invitations[0]);

        return response(410);
    }

    const invitation = freshInvitations[0];
    const registration = JSON.parse(event.body);

    const member = {
        id: context.awsRequestId, // free uuid v4 generated by aws for the request
        active: true, 
        registeredAt: new Date().toISOString(),
        email: invitation.email,
        firstname: registration.firstname,
        lastname: registration.lastname,
        birth: registration.birth,
        displayName: 'anonyme',
        address: {}
    };

    const credential = {
        email: invitation.email,
        password: bcrypt.hashSync(registration.password, 10),
        level: "member",
        memberId: member.id
    }

    if ("source" in invitation && invitation.source.type === "stripe") {
        member.stripe = { customerId: invitation.source.id };
    }

    try {
        await persist(member, credential);
    } catch (error) {
        console.error({ error, member, event, context });
        return response(500, { error: error.message, request: context.awsRequestId });
    }
    
    await purgeInvitation(invitation);

    return response(201);
};

async function fetchInvitations(id) {
    return await ddb.query({
        TableName: "invitations",
        KeyConditionExpression: "id = :id",
        ExpressionAttributeValues: {
            ":id": id
        }
    }).promise()
}

async function persist(member, credential) {
    return await ddb.transactWrite({
        TransactItems: [
            {
                Put: {
                    TableName: "members",
                    ConditionExpression: "attribute_not_exists(id)",
                    Item: member
                }
            },
            {
                Put: {
                    TableName: "credentials",
                    ConditionExpression: "attribute_not_exists(email)",
                    Item: credential
                }
            },
        ]
    }).promise();
}

async function purgeInvitation(invitation) {
    return await ddb.delete({
        TableName: "invitations",
        Key: {
            "id": invitation.id,
            "expiresAt": invitation.expiresAt
        }
    }).promise();
}

async function refreshInvitation(invitation) {
    return await sqs.sendMessage({ MessageBody: JSON.stringify({ email: invitation.email }), QueueUrl: process.env.SQS_URL_INVITATION }).promise()
}

function response(code, body, headers) {
    return {
        statusCode: code,
        body: JSON.stringify(body),
        headers: {
            'Access-Control-Allow-Origin': '*',
        },
    };
}